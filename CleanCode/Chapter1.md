
# Chapter1 無瑕的程式碼
## 索引
### 故事：
    在 80' 後期有家公司開發了殺手級的程式
    程式很熱銷，很多專家購買並使用這軟體
    後來發行的時間週期越來越長，崩潰的機率也越來越高
    直到某天，我放棄在開啟這軟體
    過了不久，這家公司也倒閉了

    二十幾年後，遇到該公司早期的一位員工，並詢問當初發生何事
    因為他們急於將產品上線，導致程式碼變成一團糟
    當他們加入越多的產品特點，程式碼就變的越來越糟
    直到他們無法管理這團混亂......劣質的程式碼導致這家公司的倒閉

### 工程師的經驗共鳴：
    你是否曾被不好的程式碼所阻礙？
    有經驗的工程師，必定感受過這樣的阻礙，更確切賦予這樣的情形一個名詞 「蹚水」(wading)
    我們努力蹚過不好的程式碼，就像艱難地走在佈滿糾結荊棘的泥潭上和隱藏的陷阱
    但是和努力尋找出路，希望得到一些提示與線索，然而卻是看到越來越多無意義的程式碼

### 雜亂程式的代價：
隨著時間的推移，開發的效率越來越差
![image](https://github.com/bensnows/Readings/blob/main/CleanCode/photo/chapter1/ch01-1.png)

### 態度：
    是否曾遇過本需要花幾小時就能完成的事，卻讓你痛不欲生了好幾個禮拜？
    是否曾遇過只需要修改一小行程式碼，卻讓你必須在幾百個不同的模組進行修改？

    為什麼會發生這樣的事？
    為何優良的程式碼如此快速的變質成劣質代碼？
    原因可能有很多：
        1. 需求一再改變
        2. 開發進度過於緊湊，導致無法把事情做好
        3. 愚蠢的主管，偏執的客戶
        ......

    但是根因，卻可能是我們本身不夠專業
    Q: 為什麼錯不在主管跟客戶呢？   
    A: 主管跟客戶必須從我們(工程師)獲取到他們要的資訊，進而去做出保證跟承諾

    Q: 為什麼錯不關開發的進度規劃呢？ 
    A: 主管想要好品質的程式，就算受到時程困擾，仍會用盡心力的保護時程跟需求，因為這是他們的工作
    
    Q: 為什麼造成雜亂是自己的錯？
    A: 但同樣用心"保護"程式碼，就是*工程師*的工作了

    若有一位病患要求醫生不要像傻子一般在手術前洗手，因為洗手會花太多時間
    如果醫生屈服於病患的要求，那就太不專業了

### 曠古難題
    開發者都知道，之前的爛程式碼，會降低新代碼的開發效率
    然而，開發者都曾感受到截止期限的壓力，所以只好產生一些爛程式來達到目標
    總之，他們並沒有花時間來讓開發速度變得更快

    但是.....爛程式真的能夠趕上截止日嗎？
    事實上，爛程式只會讓開發速度變得更慢
    在截止日期前完成工作的唯一方法，讓開發速度變快的唯一方法
    就是隨時隨地的，盡可能確保程式碼都盡可能的「整齊潔淨」


### 名人們怎麼說CleanCode
![image](https://github.com/bensnows/Readings/blob/main/CleanCode/photo/chapter1/Bjarne_stroustrup.png)
![image](https://github.com/bensnows/Readings/blob/main/CleanCode/photo/chapter1/Ward_Cunnubgham.png)

    
### 關鍵字
1. 優雅
1. 效率
1. 專注
1. 可讀性
1. 容易測試
1. 被照料過的

### 我們是作者
    在 JavaDoc中 有 @author 欄位，也就代表有「讀者」
    在 80' 年代，像 Emacs 這樣的編輯器，能追蹤每一個鍵盤敲打的動作
    可以先工作一小時，然後像加速播放影片一般，重播整個編輯階段

    重播畫面顯示，絕大多數的動作都在捲軸移動及瀏覽其他模組
    花茝閱讀程式碼與花在寫程式碼的時間，大約是10:1
    當要撰寫新的程式碼前，其實先花了不少功夫在不斷地瞭解舊的程式碼

    程式碼易讀 -> 程式碼容易開發

### 童子軍準則
    離開營地前，讓營地比使用前更加乾淨
    每次 commit 的代碼，都比原本的代碼更為乾淨.....
